// sched.c
// Created by Jeremy McCormick on 2/4/19.
// Schedules and loads new processes generated by procgen. sched() loads the new 
// files and picks which one to run. run() then runs it with random I/O blocks.


#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <unistd.h>
#include "proc.h"
#include "sched.h"
//Functions
void clearScreen();
void printRun();
int doesIOBlock();
int run(int num);
void loadNew();
void enqueue(int num, int prior);
int dequeue(int priority);
int sched();

//Globals
FILE * fp;
long clk;
int queue[4][10001];
int head[4];//Head and tail for each queue
int tail[4];
int size[4];// One for each priority
int counter = 0;;


int main(int argc, char **argv) {
    for(int i = 0; i < 4; i++) {
        head[i] = 10000;
        tail[i] = 10000;
        size[i] = 0;
    }
    sched();
    while(size[0] > 0 || size[1] > 0 || size[2] > 0 || size[3] > 0) {
        sched();
    }
}

void clearScreen()
{
    const char *CLEAR_SCREEN_ANSI = "\e[1;1H\e[2J";
    fprintf(stdout, CLEAR_SCREEN_ANSI, 12);
}
void printRun() {
    printf("Now Running file num : %d\n", getNumber());
    printf("Location: %i\n",getWhereAt());
    printf("Priority: %i\n",getPriority());
    printf("ExecTime: %i\n",getTime());
    printf("Memory: %i\n", getMemory());

}

int doesIOBlock() {
    int ran =  rand();
    int r = (ran % 100);
    if(r < 2)
        return 1;
    return 0;
}

int run(int num) {
    int chk = openProc(num);
    if(chk == 1)
        return 1;
    printRun();
    int c = getNext();
    while(c != 0 && c != -1){
        if(doesIOBlock() == 1) {
            closeProc();
            return -1;
        }
        clk += c;
        c = getNext();
        printf("Next Exec : %d\n", c);
    }
    closeProc();
    return 0;
}

int sched() {
    loadNew();
     for(int i = 0; i < 4; i++) {
           //Gets current size, to avoid enqueue continually running same thing.
          for(int currentsize = size[i];  currentsize > 0 ; currentsize--) {
              int next = dequeue(i);
              int ret = run(next);
              if(ret == -1)
                  enqueue(next, i);
          }
     }
    return 0;
}

void loadNew() {
    //Check for new files
    char buf[100];
    //Open with counter filename
    snprintf(buf, sizeof(buf), "%i.proc", counter);
    
    while(access(buf, F_OK) != -1) {
        openProc(counter);
        int priority = getPriority();
        closeProc();
        enqueue(counter, priority);
        counter++;
        //Open with counter filename
        snprintf(buf, sizeof(buf), "%i.proc", counter);
    }
}

void enqueue(int num, int prior) {
    queue[prior][head[prior]] = num;
    head[prior]--;
    if(tail[prior] == 0)
        tail[prior] = 10000;
    size[prior]++;
}

int dequeue(int priority) {
    if(size[priority] == 0) {
        return -1;
    }
    int ret = queue[priority][tail[priority]];
    tail[priority]--;
    if(tail[priority] == 0)
        tail[priority] = 10000;
    size[priority]--;
    return ret;
}
